---
title: "gRPC 学习笔记 Java 版"
author: chancelor
date: 2025-02-14 01:37:00 +0800
categories: [微服务, RPC]
tags: [微服务, RPC, gRPC]
media_subpath: /assets/img/posts/2025-02-14/
---

## gRPC 简介

gRPC 是由 Google 开源的一个高性能 RPC 框架

## Protobuf 语法

安装 Protobuf: `brew install protobuf`，测试是否安装完成: `protoc --version`。

Protobuf 文件以`.proto`结尾，通常放置在模块下的`src/main/proto`目录下。2021.2 或更高版本的 IDEA 已经内置了 Protobuf 插件，所以可以直接在 IDEA 内编写。



Protobuf 有 2 和 3 这两个版本，在`.proto`文件的第一行必须指定所使用的版本 (通常是`proto3`)

```protobuf
syntax = "proto3";
```



Protobuf 提供了一些与 Java 相关的语法，以`option`开头，常用的有以下几个: 

- 指定 Protobuf 生成的 Java 代码在一个还是多个 Java 文件中

```protobuf
option java_multiple_files = false;
```

- 指定 Protobuf 生成的 Java 类放置在哪个包下

```protobuf
option java_package = "xxx";
```

> 另一种指定包的方式: `package xxx;`，这种方式指定的是 Protobuf 的逻辑包，适用于任何语言，而对于 Java 来说，两种方式都可。
{: .prompt-tip }

- 指定外层类的类名，后续 Protobuf 生成的多个 Java 类都会作为该类的内部类 。外部类除了管理内部类没有其它作用，开发中真正使用的是内部类，可通过`ProtoOuterClass.InnerClass`进行访问

```protobuf
option java_outer_classname = "ProtoOuterClass";
```



一个 Protobuf 文件中也可以导入其它 Protobuf，语法为: 

```protobuf
import "xxx/UserService.proto";
```



gRPC 中通信双方传递的数据叫做`message`，它在 Protobuf 中的定义形式如下。`message`中每个字段都需要一个唯一的编号，用于在二进制数据中标识该字段，确保在消息解码过程中可以准确识别每个字段。编号的取值范围为 [1, 2^29 - 1]，1～15 范围内的编号在编码时会占用一个字节，编码越大占用的字节数也会越多。

Protobuf 也支持枚举类型`enum`，不过要注意枚举值必须从 0 开始。Protobuf 支持的所有数据类型详见 [https://protobuf.dev/programming-guides/proto3/#scalar](https://protobuf.dev/programming-guides/proto3/#scalar)。

`message`中字段可以有两种修饰符: `singular`和`repeated`，`singular`是默认值，表示该字段的值只能是 0 个 (null) 或 1 个，而`repeated`表示该字段可以有多个值，生成 Java 代码后就是一个`List`，且方法名会自动加上后缀比如`getTokenList()`。

```protobuf
message User {
  enum Type {
    VISITOR = 0;
    COMMON = 1;
    VIP = 2;
  }
  int64 userId = 1;
  string username = 2;
  bool isLogin = 3;
  Type type = 4;
  repeated string token = 5;
}
```



Protobuf 中 RPC 服务接口定义为`service`，每个方法都以`rpc`关键字开头，参数和返回值都只需要写类型，另外根据通信方式的不同还可以加上`stream`关键字 (详见后续): 

```protobuf
service HelloService {
  rpc hello(Request) returns (Response);
}
```

## QuickStart

开发一个 gRPC 项目通常需要有三个模块，项目结构为:

- grpc-api 模块: 定义服务接口和参数的 Protobuf IDL，并生成对应的 Java 代码
- grpc-service 模块: 实现服务接口，创建服务端程序并发布服务
- grpc-client 模块: 创建服务代理 Stub，基于 Stub 调用 RPC 服务

### API

在 grpc-api 模块的`src/main`下创建`proto`目录用于统一管理`.proto`文件 (该目录也是 Protobuf Maven 插件的默认编译目录)，然后编写`hello.proto`定义参数和服务接口。

```protobuf
syntax = "proto3";

option java_multiple_files = false;
option java_package = "hello";
option java_outer_classname = "HelloOuterClass";

message HelloRequest {
  string name = 1;
}

message HelloResponse {
  string result = 1;
}

service HelloService {
  rpc hello(HelloRequest) returns (HelloResponse);
}
```

编写完成后，可以使用`protoc`命令把`.proto`文件中 IDL 转换成 Java 代码，不过更常用的方法是使用 [Protobuf Maven 插件](https://github.com/grpc/grpc-java)，根据文档进行操作，首先需要导入几个依赖以及安装插件。

```xml
<dependency>
  <groupId>io.grpc</groupId>
  <artifactId>grpc-netty-shaded</artifactId>
  <version>1.70.0</version>
  <scope>runtime</scope>
</dependency>
<dependency>
  <groupId>io.grpc</groupId>
  <artifactId>grpc-protobuf</artifactId>
  <version>1.70.0</version>
</dependency>
<dependency>
  <groupId>io.grpc</groupId>
  <artifactId>grpc-stub</artifactId>
  <version>1.70.0</version>
</dependency>
<dependency> <!-- necessary for Java 9+ -->
  <groupId>org.apache.tomcat</groupId>
  <artifactId>annotations-api</artifactId>
  <version>6.0.53</version>
  <scope>provided</scope>
</dependency>

<build>
  <extensions>
    <extension>
      <groupId>kr.motd.maven</groupId>
      <artifactId>os-maven-plugin</artifactId>
      <version>1.7.1</version>
    </extension>
  </extensions>
  <plugins>
    <plugin>
      <groupId>org.xolstice.maven.plugins</groupId>
      <artifactId>protobuf-maven-plugin</artifactId>
      <version>0.6.1</version>
      <configuration>
        <protocArtifact>com.google.protobuf:protoc:3.25.5:exe:${os.detected.classifier}</protocArtifact>
        <pluginId>grpc-java</pluginId>
        <pluginArtifact>io.grpc:protoc-gen-grpc-java:1.70.0:exe:${os.detected.classifier}</pluginArtifact>
      </configuration>
      <executions>
        <execution>
          <goals>
            <goal>compile</goal>
            <goal>compile-custom</goal>
          </goals>
        </execution>
      </executions>
    </plugin>
  </plugins>
</build>
```

然后执行 Maven 插件的`complie`命令就可以将`message`编译成 Java 代码，类名就是源文件中定义的外部类名`HelloOuterClass`，再执行`complie-custom`命令将`service`编译成服务类，类名 Service 名加上 Grpc 后缀`HelloServiceGrpc`。

插件默认会把 Java 文件编译到`target`目录下，构建时可能会找不到类，需要多次执行`mvn clean install`，不过即使构建没问题了 IDEA 可能还是会有错误提示。如果想编译到源代码目录下，就需要插件的`<configuration>`下指定输出目录。

```xml
<configuration>
    <outputDirectory>${basedir}/src/main/java</outputDirectory>
    <clearOutputDirectory>false</clearOutputDirectory>
</configuration>
```

添加配置后再重新生成 Java 代码包结构为:

![grpc-api-maven-plugin](grpc-api-maven-plugin.png){: .w-50}

`HelloOuterClass`和`HelloServiceGrpc`的类结构如下图，内部类`HelloRequest`和`HelloResponse`就是 RPC 请求和响应参数；`HelloServicelmp|Base`是真正的服务接口，实现服务时需继承该抽象类；以`Stub`结尾的几个类就是客户端的代理，它们的区别在于网络通信方式不同。

![grpc-api](grpc-api.jpg){: .w-65}

### Service

grpc-service 模块首先要实现 api 模块中定义的服务接口，业务逻辑很简单，就是接收`name`参数并打印出来，然后返回`Hello, [name]!`给客户端。第一步是继承抽象服务`HelloServiceImplBase`并重写服务接口。

```java
public class HelloServiceImpl extends HelloServiceGrpc.HelloServiceImplBase {
    @Override
    public void hello(HelloOuterClass.HelloRequest request, StreamObserver<HelloOuterClass.HelloResponse> responseObserver) {
        // 接收请求参数
        String name = request.getName();
        System.out.println("name = " + name);
        // 构造返回对象并填充数据 (构造者模式)
        HelloOuterClass.HelloResponse.Builder builder = HelloOuterClass.HelloResponse.newBuilder();
        builder.setResult("Hello, " + name + "!");
        HelloOuterClass.HelloResponse response = builder.build();
        // 发送响应
        responseObserver.onNext(response);
        // 关闭连接
        responseObserver.onCompleted();
    }
}
```

首先，服务通过`HelloRequest`接收响应参数，然后再使用构造者模式构建出`HelloResponse`的构建：先调用`newBuidler`创建构造者，再通过构造者填充数据，最后调用`build`获得相应对象。

从代码中还可以看出，响应并不是由服务接口直接返回，而是封装到一个`StreamObserver`参数中，利用它的`onNext`方法将响应发送给客户端。`StreamObserver`接口从命名上就可以看出它使用了观察者模式，而观察者模式涉及到两个角色：观察者负责提供回调函数，被观察者 (或者叫主题) 负责在状态发送变化时通过回调函数通知观察者，所以在服务端发送响应这个过程中，观察者就是 gRPC 框架 (或者说是`StreamObserver`接口)，它在底层实现中提供了回调函数负责将响应发送给客户端，被观察者则是`HelloResponse`，当服务收到请求并处理完业务逻辑后，就调用`onNext`回调将响应推送给 gRPC。

发送完响应之后，还需要调用`onCompleted`方法，它会给客户端返回一个标记 (同样是观察者模式)，客户端监听到标记后才会结束整个流程。



gRPC 框架没有借用 Tomcat 等现成的服务器，所以还要自己写服务端，不过 gRPC 底层对 Netty 进行了封装，我们直接调用就行，只需要四步：绑定端口 -> 发布服务 -> 创建并启动 Server -> 等待请求。

```java
public class GrpcServer {
    public static void main(String[] args) throws IOException, InterruptedException {
        // 绑定端口
        ServerBuilder serverBuilder = ServerBuilder.forPort(9000);
        // 发布服务
        serverBuilder.addService(new HelloServiceImpl());
        // 创建Server
        Server server = serverBuilder.build();
        server.start();
        server.awaitTermination();
    }
}
```

### Client

grpc-client 模块只要开发客户端程序，步骤为:

1. 创建通信管道`ManagedChannel` (因为底层 Netty 通信需要管道)，指定服务端地址和交互方式
2. 获取客户端服务代理`Stub`
3. 构造请求参数，通过`Stub`像调用本地方法一样进行调用 RPC
4. 关闭通信管道

```java
public class GrpcClient {
    public static void main(String[] args) throws InterruptedException {
        // 创建通信管道
        ManagedChannel channel = ManagedChannelBuilder.forAddress("localhost", 9000).usePlaintext().build();
        // 获取代理对象Stub
        HelloServiceGrpc.HelloServiceBlockingStub helloService = HelloServiceGrpc.newBlockingStub(channel);
        // RPC调用
        HelloOuterClass.HelloRequest request = HelloOuterClass.HelloRequest.newBuilder()
                .setName("Chancelor")
                .build();
        HelloOuterClass.HelloResponse response = helloService.hello(request);
        System.out.println("result = " + response.getResult());
        channel.shutdown();
    }
}
```

通信管道和参数的创建都使用了构造者模式，服务代理则使用了`BlockingStub`，调用 RPC 后会一直阻塞，直到收到服务端执行`onCompleted`发送的标记后才能继续执行。

### 运行结果

![unary-result](unary-result.png)

## 通信方式

gRPC 有四种通信方式:

- 一元 RPC (Unary RPC)
- 服务端流式 RPC (Server Streaming RPC)
- 客户端流式 RPC (Client Streaming RPC)
- 双向端流式 RPC (Bidirectional Streaming RPC)

### 一元 RPC

一元 RPC 就是请求响应式的通信方式，客户端像调用本地本地方法一样发起单个请求，服务端收到并处理后返回单个响应，期间客户端阻塞等待。QuickStart 程序就是一元 RPC，客户端使用的代理是`BlockingStub`。

![unary-rpc](unary-rpc.svg)

### 服务端流式 RPC

服务端流式 RPC 特点是客户端发送一个请求，服务端返回一个流式响应。服务端可以通过流向服务端发送多个消息，且 gRPC 可以保证单个流 (即一次 RPC 调用) 中消息的顺序，所以客户端会按发送顺序接收服务端的消息。

适用场景:

- 服务端需要发送不同时刻的实时数据
- 服务端分批发送大量数据
- 服务端开启多线程处理请求，多个线程各自返回消息给客户端

![server-streaming-rpc](server-streaming-rpc.svg)

__代码实现: __

在`.proto`文件中定义服务端流式接口，语法就是在`service`返回值前加上`stream`关键字:

```protobuf
service HelloService {
  rpc c2ss(HelloRequest) returns (stream HelloResponse);
}
```

然后在服务端实现该接口，业务逻辑就是开启多个线程发送`Hello`字符串的每个字符，发送前让线程随机睡眠一段时间模拟业务处理。主线程等待发送完成后再调用`onCompleted`结束通信。

```java
public class HelloServiceImpl extends HelloServiceGrpc.HelloServiceImplBase {
    private final ExecutorService THREAD_POOL = Executors.newFixedThreadPool(5);

    @Override
    public void c2ss(HelloOuterClass.HelloRequest request, StreamObserver<HelloOuterClass.HelloResponse> responseObserver) {
        String name = request.getName();
        System.out.println("name = " + name);
        HelloOuterClass.HelloResponse.Builder builder = HelloOuterClass.HelloResponse.newBuilder();
        CountDownLatch countDownLatch = new CountDownLatch(5);
        for (int i = 0; i < 5; i++) {
            int ii = i;
            THREAD_POOL.submit(() -> {
                try {
                    Thread.sleep((int) (Math.random() * 501) + 500);
                } catch (InterruptedException e) {
                    System.out.println("Thread interrupted");
                    return;
                }
                synchronized (builder) {
                    builder.setResult(String.valueOf("Hello".charAt(ii)));
                    responseObserver.onNext(builder.build());
                    countDownLatch.countDown();
                }
            });
        }
        try {
            countDownLatch.await();
        } catch (InterruptedException e) {
            System.out.println("CountDownLatch await interrupted");
        }
        responseObserver.onCompleted();
    }
}
```





